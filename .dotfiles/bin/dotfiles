#!/bin/bash

# curl -s https://raw.githubusercontent.com/lesurp/dotfiles/master/.dotfiles/bin/dotfiles | bash

# sets the function ctr_c as a callback when SIGINT (^C) is received
trap ctrl_c INT
ctrl_c() {
    printf "SIGINT received - aborting!\n"
    exit 1
}

# fuse2 is erquired to run nvim from the AppImage
# node / npm are for the cocnvim runtime
# xclip for clipboard support
# cppman is an offline cpp std lib documentation
read -d '' DOTFILES_PACMAN_PACKAGES << EOF
wget curl sudo zsh git kitty which firefox xorg-xinit python-pip

i3 dmenu network-manager network-manager-applet dunst

fuse2 nodejs npm xclip

clang clang++ cppman cmake
EOF

# Those are to be installed with cargo
read -d '' DOTFILES_CARGO_PACKAGES << EOF
ripgrep
cargo-edit
EOF


############################################## GLOBAL VARS
DOTFILES_UPSTREAM_REPO=https://github.com/lesurp/dotfiles
DOTFILES_HOME=$HOME/.dotfiles
DOTFILES_REPO=$DOTFILES_HOME/repo
DOTFILES_BINARY_DIR=$DOTFILES_HOME/bin
DOTFILES_INSTALL_DIR=$DOTFILES_HOME/install
DOTFILES_CONFIG_FILE=$DOTFILES_HOME/config
if [ -f $DOTFILES_CONFIG_FILE ]; then
    source $DOTFILES_CONFIG_FILE
else
    # if the config file does not exist, assume first run (and create dirs etc.)
    mkdir -p $DOTFILES_BINARY_DIR
    mkdir -p $DOTFILES_INSTALL_DIR
fi


# Each module should append its configuration to this variable
# We stores its value to the above file
DOTFILES_CONFIG_OUT=""
append_config() {
    DOTFILES_CONFIG_OUT+="export $1=${!1}\n"
}

# we store those in the conf because the variables are sourced on session startup
append_config DOTFILES_BINARY_DIR # when setting up the path
append_config DOTFILES_REPO       # config git alias
append_config DOTFILES_HOME       # just in case

# Each config should use this when saving state
# Don't forget that the variables may be empty!
TRUE="true"

# avoid using the root pass if sudo is installed (as it might not be known)
# otherwise use su and install sudo in the process
# this is done only once to avoid e.g. installing sudo during the script and breaking everything else
# this also requires only one password prompt
if hash sudo 2>/dev/null
then
    root_cmd="sudo sh -c"
else
    root_cmd="su -c"
fi

root() {
    ${root_cmd} "$@"
}

next() {
    printf -- '=%.0s' {1..80}
    printf "\nSTARTING: $1\n"
    printf -- '-%.0s' {1..40} \n
    printf "\n"
    $@
}

############################################## SYSTEM PACKAGE INSTALL
### found from pacapt
# Detect package type from /etc/issue
# and set the package_man variable to the corresponding keyword
found_arch() {
    grep -qis "$2" /etc/issue && package_man="$1"
}

# Detect package type
find_package_manager() {
    found_arch PACMAN "Arch Linux" && return
    found_arch DPKG   "Debian GNU/Linux" && return
    found_arch DPKG   "Ubuntu" && return
    #found_arch YUM    "CentOS" && return
    #found_arch YUM    "Red Hat" && return
    #found_arch YUM    "Fedora" && return
    #found_arch ZYPPER "SUSE" && return
    echo "Couldn't detect OS type (or it's not supported). Exiting..."
    exit 1
}

find_update_cmd() {
    case $1 in
        PACMAN) update_cmd="pacman -Syu --noconfirm"; return;;
        DPKG)   update_cmd="apt-get update; apt-get upgrade -y"; return;;
        YUM)    update_cmd="yum"; return;;
        ZYPPER) update_cmd="zypper"; return;;
    esac
}

find_install_cmd() {
    case $1 in
        PACMAN) install_cmd="pacman -S --noconfirm"; return;;
        DPKG)   install_cmd="apt-get install"; return;;
        YUM)    install_cmd="yum"; return;;
        ZYPPER) install_cmd="zypper"; return;;
    esac
}

github_latest_tag() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | sed -n 's/^.*"tag_name": "\(.*\)".*$/\1/p'
}

initialize_package_manager() {
    find_package_manager
    # used to update the package list, and upgrade the packages themselves
    find_update_cmd $package_man
    # used to install any new package
    find_install_cmd $package_man
    root "$update_cmd"
}

# also setup zsh as the user's default shell
install_packages() {
    # this is needed because xargs SUCKS
    local packages=$(sed 's/ /\n/g' <<< $@)
    # avoid stopping on non-existing packages (for different package managers)
    install_all_pkgs="echo \"$packages\" | xargs -I{} $install_cmd {}"
    root "$install_all_pkgs"
}

install_system_packages() {
    initialize_package_manager

    if [ "$DOTFILES_CONFIG_SYSTEM_INSTALLED" != $TRUE ]; then
        install_packages $@
    fi

    DOTFILES_CONFIG_SYSTEM_INSTALLED=$TRUE
    append_config DOTFILES_CONFIG_SYSTEM_INSTALLED
}
############################################## SYSTEM PACKAGE INSTALL END

############################################## INSTALL NEOVIM
NVIM_LOCATION=$DOTFILES_BINARY_DIR/nvim
NVIM_CONFIG_DIR=$HOME/.config/nvim

install_nvim() {
    # TODO: check commit of the nightly-release to avoid redownloading same version every run
    wget https://github.com/neovim/neovim/releases/download/nightly/nvim.appimage -O $NVIM_LOCATION
    chmod +x $NVIM_LOCATION

    if [ "$DOTFILES_CONFIG_NVIM_INSTALLED" == $TRUE ]; then
        $NVIM_LOCATION +PlugUpdate +qa
    else
        curl -fLo $NVIM_CONFIG_DIR/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        $NVIM_LOCATION +PlugInstall +qa
        pip3 install neovim-remote --user
    fi

    DOTFILES_CONFIG_NVIM_INSTALLED=$TRUE
    append_config DOTFILES_CONFIG_NVIM_INSTALLED
}

############################################## INSTALL KITTY
KITTY_INSTALL=$DOTFILES_INSTALL_DIR/kitty
KITTY_BINARY=$DOTFILES_BINARY_DIR/kitty
KITTY_REPO=kovidgoyal/kitty
install_kitty() {
    local latest_tag=`github_latest_tag ${KITTY_REPO}`
    # remove first letter of the tag (which is the 'v' in front of the actualy version number)
    latest_tag=${latest_tag#?};
    local kitty_download_link="https://github.com/${KITTY_REPO}/releases/download/v${latest_tag}/kitty-${latest_tag}-x86_64.txz"
    if [ -z "$DOTFILES_CONFIG_KITTY_VERSION" ]; then
        printf "Installing kitty version ${latest_tag}"
        mkdir ${KITTY_INSTALL}
        wget -qO- https://github.com/${KITTY_REPO}/releases/download/v${latest_tag}/kitty-${latest_tag}-x86_64.txz | tar -xJ -C ${KITTY_INSTALL}
        ln -s ${KITTY_INSTALL}/bin/kitty ${KITTY_BINARY}
    elif [ "$DOTFILES_CONFIG_KITTY_VERSION" != "${latest_tag}" ]; then
        printf "Upgrading to kitty version ${latest_tag}"
    else
        printf "Kitty already up-to-date"
    fi

    DOTFILES_CONFIG_KITTY_VERSION=${latest_tag}
    append_config DOTFILES_CONFIG_KITTY_VERSION
}

############################################## INSTALL CONFIG
install_repo() {
    if [ "$DOTFILES_CONFIG_REPO_INSTALLED" == $TRUE ]; then
        printf "Repository was already cloned, nothing else to do here.\n"
        append_config DOTFILES_CONFIG_REPO_INSTALLED
        return
    fi

    git clone --bare $DOTFILES_UPSTREAM_REPO $DOTFILES_REPO
    config="git --git-dir=${DOTFILES_REPO} --work-tree=${HOME}"
    $config config status.showUntrackedFiles no
    branch_name=master
    ## FIXME: this doesn't actually work when piping through curl?
    ## i.e. it's always detected as being interactive which obv. fucks up everything
    # if this is an interactive shell, prompt the user for a new branch name for this config
    #if [ -t 1 ]; then
    #    echo "The existing configurations are:"
    #    $config branch -a | tail -n +2 | cut -d"/" -f2
    #    printf "Enter a desired configuration branch.\n"
    #    read -p "If it doesn't exist, it will be created based on master. " branch_name
    #    if [ -z "${branch_name}" ]; then
    #        branch_name=master
    #    fi
    #else
    #    branch_name=master
    #fi
    # Note that this does not delete uncommitted changes!
    $config checkout -B ${branch_name}

    printf "Set dotfiles' configuration branch to ${branch_name}\n"

    DOTFILES_CONFIG_REPO_INSTALLED=$TRUE
    append_config DOTFILES_CONFIG_REPO_INSTALLED
}

############################################## INSTALL ZSH
DOTFILES_ZSH_HOME=$HOME/.zsh
DOTFILES_ZSH_COMPLETIONS=$DOTFILES_ZSH_HOME/completions

install_zsh() {
    mkdir -p $DOTFILES_ZSH_COMPLETIONS

    local user=$(whoami)
    root "chsh -s $(which zsh) $user"

    printf "Set ${user}'s shell to zsh\n"

    append_config DOTFILES_ZSH_HOME
    append_config DOTFILES_ZSH_COMPLETIONS
}

############################################## INSTALL RUSTUP / CARGO
install_rustup() {
    if [ "$DOTFILES_CONFIG_RUSTUP_INSTALLED" == $TRUE ]; then
        printf "Updating rust install...\n"
        rustup update
    else
        printf "Installing rust toolchain...\n"
        curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain nightly --no-modify-path
        DOTFILES_CONFIG_RUSTUP_INSTALLED=$TRUE
    fi
    rustup component add rust-src
    rustup completions zsh > $DOTFILES_ZSH_COMPLETIONS/_rustup
    rustup completions zsh cargo > $DOTFILES_ZSH_COMPLETIONS/_cargo
    local packages=$(sed 's/ /\n/g' <<< "${DOTFILES_CARGO_PACKAGES}")
    echo "$packages" | xargs -I{} cargo install {}

    printf "Update/installation of rust toolchain/packages finished\n"

    append_config DOTFILES_CONFIG_RUSTUP_INSTALLED
}

next install_system_packages "$DOTFILES_PACMAN_PACKAGES"
next install_repo
next install_nvim
next install_zsh
next install_kitty
next install_rustup

# Save the conf
printf "$DOTFILES_CONFIG_OUT" > $DOTFILES_CONFIG_FILE
printf "source ${DOTFILES_CONFIG_FILE}" > .zshenv
