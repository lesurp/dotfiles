#!/bin/bash

# curl -s https://raw.githubusercontent.com/lesurp/dotfiles/master/.dotfiles/bin/dotfiles | bash

save_conf() {
    printf "$DOTFILES_CONFIG_OUT" > $DOTFILES_CONFIG_FILE
}

read -d '' DOTFILES_PACMAN_PACKAGES << EOF
wget curl sudo git
which patch fakeroot pkg-config

sway dunst feh network-manager wl-clipboard
network-manager-applet volumeicon volumeicon-alsa pavucontrol flameshot
firefox pass zathura

noto-fonts-emoji ttf-fira-code fonts-noto-color-emoji fonts-firacode fonts-noto

python-pip pip
clang clang++ gcc g++ cppman cmake make
EOF

# Those are to be installed with cargo
read -d '' DOTFILES_CARGO_PACKAGES << EOF
ripgrep
cargo-edit
fd-find
nu
ripdrag
zoxide
cargo-audit
cargo-deny
EOF


############################################## GLOBAL VARS
DOTFILES_UPSTREAM_REPO=https://github.com/lesurp/dotfiles
DOTFILES_HOME=$HOME/.dotfiles
DOTFILES_REPO=$DOTFILES_HOME/repo
DOTFILES_BINARY_DIR=$DOTFILES_HOME/bin
DOTFILES_INSTALL_DIR=$DOTFILES_HOME/install
DOTFILES_CONFIG_FILE=$DOTFILES_HOME/config
if [ -f $DOTFILES_CONFIG_FILE ]; then
    source $DOTFILES_CONFIG_FILE
else
    # if the config file does not exist, assume first run (and create dirs etc.)
    mkdir -p $DOTFILES_BINARY_DIR
    mkdir -p $DOTFILES_INSTALL_DIR
fi

# sets the function ctr_c as a callback when SIGINT (^C) is received
trap ctrl_c INT
ctrl_c() {
    printf "SIGINT received - saving the conf then aborting!\n"
    mv $DOTFILES_CONFIG_FILE $DOTFILES_CONFIG_FILE.bkp
    save_conf
    exit 1
}


# Each module should append its configuration to this variable
# We stores its value to the above file
DOTFILES_CONFIG_OUT=""
append_config() {
    DOTFILES_CONFIG_OUT+="export $1=${!1}\n"
    save_conf
}

# we store those in the conf because the variables are sourced on session startup
append_config DOTFILES_BINARY_DIR
append_config DOTFILES_REPO      
append_config DOTFILES_HOME       
append_config DOTFILES_INSTALL_DIR

# Each config should use this when saving state
# Don't forget that the variables may be empty!
TRUE="true"

# avoid using the root pass if sudo is installed (as it might not be known)
# otherwise use su and install sudo in the process
# this is done only once to avoid e.g. installing sudo during the script and breaking everything else
# this also requires only one password prompt
if hash sudo 2>/dev/null
then
    root_cmd="sudo sh -c"
else
    root_cmd="su -c"
fi

root() {
    ${root_cmd} "$@"
}

next() {
    printf -- '=%.0s' {1..80}
    printf "\nSTARTING: $1\n"
    printf -- '-%.0s' {1..40} \n
    printf "\n"
    $@
}

############################################## SYSTEM PACKAGE INSTALL
### found from pacapt
# Detect package type from /etc/issue
# and set the package_man variable to the corresponding keyword
found_arch() {
    grep -qis "$2" /etc/issue && package_man="$1"
}

# Detect package type
find_package_manager() {
    found_arch PACMAN "Arch Linux" && return
    found_arch DPKG   "Debian GNU/Linux" && return
    found_arch DPKG   "Ubuntu" && return
    #found_arch YUM    "CentOS" && return
    #found_arch YUM    "Red Hat" && return
    #found_arch YUM    "Fedora" && return
    #found_arch ZYPPER "SUSE" && return
    echo "Couldn't detect OS type (or it's not supported). Exiting..."
    exit 1
}

find_update_cmd() {
    case $1 in
        PACMAN) update_cmd="pacman -Syu --noconfirm"; return;;
        DPKG)   update_cmd="apt-get update; apt-get upgrade -y"; return;;
        YUM)    update_cmd="yum"; return;;
        ZYPPER) update_cmd="zypper"; return;;
    esac
}

find_install_cmd() {
    case $1 in
        PACMAN) install_cmd="pacman -S --noconfirm"; return;;
        DPKG)   install_cmd="apt-get install -yq"; return;;
        YUM)    install_cmd="yum"; return;;
        ZYPPER) install_cmd="zypper"; return;;
    esac
}

initialize_package_manager() {
    find_package_manager
    # used to update the package list, and upgrade the packages themselves
    find_update_cmd $package_man
    # used to install any new package
    find_install_cmd $package_man
    root "$update_cmd"
}

install_system() {
    initialize_package_manager

    if [ "$DOTFILES_CONFIG_SYSTEM_INSTALLED" != $TRUE ]; then
        # this is needed because xargs SUCKS
        local packages=$(sed 's/ /\n/g' <<< $DOTFILES_PACMAN_PACKAGES)
        # avoid stopping on non-existing packages (for different package managers)
        install_all_pkgs="echo \"$packages\" | xargs -I{} $install_cmd {}"
        root "$install_all_pkgs"
    fi

    DOTFILES_CONFIG_SYSTEM_INSTALLED=$TRUE
    append_config DOTFILES_CONFIG_SYSTEM_INSTALLED
}
############################################## SYSTEM PACKAGE INSTALL END

install_helix() {
    DOTFILES_HELIX_DIR=$DOTFILES_INSTALL_DIR/helix
    [ ! -d $DOTFILES_HELIX_DIR ] && git clone https://github.com/helix-editor/helix/ $DOTFILES_HELIX_DIR

    cd $DOTFILES_HELIX_DIR
    git pull

    cargo install \
       --profile opt \
       --config 'build.rustflags="-C target-cpu=native"' \
       --path helix-term \
       --locked

    HELIX_RUNTIME=$DOTFILES_INSTALL_DIR/helix/runtime

    append_config HELIX_RUNTIME
    append_config DOTFILES_HELIX_DIR
}

############################################## INSTALL CONFIG
install_repo() {
    if [ "$DOTFILES_CONFIG_REPO_INSTALLED" == $TRUE ]; then
        printf "Repository was already cloned, nothing else to do here.\n"
        append_config DOTFILES_CONFIG_REPO_INSTALLED
        return
    fi

    git clone --bare $DOTFILES_UPSTREAM_REPO $DOTFILES_REPO
    config="git --git-dir=${DOTFILES_REPO} --work-tree=${HOME}"
    $config config status.showUntrackedFiles no
    $config remote set-url origin git@github.com:lesurp/dotfiles.git
    branch_name=master
    $config checkout -B ${branch_name}

    printf "Set dotfiles' configuration branch to ${branch_name}\n"

    DOTFILES_CONFIG_REPO_INSTALLED=$TRUE
    append_config DOTFILES_CONFIG_REPO_INSTALLED
}

install_nu_scripts() {
    DOTFILES_NU_SCRIPTS_DIR=$DOTFILES_INSTALL_DIR/nu_scripts
    [ ! -d $DOTFILES_NU_SCRIPTS_DIR ] && git clone https://github.com/nushell/nu_scripts $DOTFILES_NU_SCRIPTS_DIR
    cd $DOTFILES_NU_SCRIPTS_DIR
    git pull
    append_config DOTFILES_NU_SCRIPTS_DIR
}

############################################## INSTALL RUSTUP / CARGO
install_rustup() {
    if [ "$DOTFILES_CONFIG_RUSTUP_INSTALLED" == $TRUE ]; then
        printf "Updating rust install...\n"
        rustup update
    else
        printf "Installing rust toolchain...\n"
        curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain nightly --no-modify-path
        DOTFILES_CONFIG_RUSTUP_INSTALLED=$TRUE
    fi
    rustup="$HOME/.cargo/bin/rustup"
    $rustup component add rust-src rustfmt clippy rustc-codegen-cranelift-preview
    local packages=$(sed 's/ /\n/g' <<< "${DOTFILES_CARGO_PACKAGES}")
    echo "$packages" | xargs -I{} $HOME/.cargo/bin/cargo install {} --locked

    printf "Update/installation of rust toolchain/packages finished\n"

    append_config DOTFILES_CONFIG_RUSTUP_INSTALLED
}

installers="system repo rustup helix nu_scripts"
if [[ $# -eq 0 ]]; then
    to_be_installed=$installers
else
    for installer in $@
    do
        if [[ " $installers " =~ " $installer " ]]; then
            to_be_installed="$to_be_installed $installer"
        else
            printf "Install \'$installer\' does not exist; aborting!\n"
            exit 1
        fi
    done
fi

printf "Installing:$to_be_installed\n"
for installer in $to_be_installed
do
    next install_$installer
done
